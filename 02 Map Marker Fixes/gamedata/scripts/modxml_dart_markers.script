DART.MARKERS = {}


local log = DART.logger"MARKERS"
local setCache, applyCache = DART.cache"MARKERS"


local MARKER_INDEX, TOUCHED = {}, {}


function isResizable(DXML, element)
  if not DXML:isElement(element) then
    return false
  end

  local name = DXML:getElementName(element)

  if name == "texture" or name:match("^texture_") then
    return false
  end

  local width  = DXML:getElementAttr(element).width
  local height = DXML:getElementAttr(element).height

  if
    not width or not height
    or width == "0" or height == "0"
  then
    return false
  end

  return true
end


function resizePDAMarker(DXML, element)
  local attrs = DXML:getElementAttr(element)
  local name  = DXML:getElementName(element)

  local angle = attrs.heading_angle or 0
  local widthChange  = attrs.width
  local heightChange = attrs.height

  -- factor aspect ratio (PDA works best using 16:9 as basis)
  widthChange  = widthChange * (DART.getAspectRatioVs16x9() - 1)
  heightChange = widthChange * (DART.getAspectRatioVs16x9() - 1)

  -- factor angle and scale down if not 90 degrees
  widthChange  = widthChange * (DART.abcosd(angle) - 0.5 * (angle % 90) / 45)
  heightChange = heightChange * (DART.absind(angle) - 0.5 * (angle % 90) / 45)

  DXML:setElementAttr(element, {
    width = attrs.width + widthChange,
    height = attrs.height + heightChange,
    stretch = 1,
  })

  -- Extra fudge factor for blinky things
  if name == "static_border" then
    DXML:setElementAttr(element, {x = attrs.x + 1})
  end

  -- this specific animation gets distorted
  DXML:removeElementAttr(element, {"xform_anim"})
end


function adjustMinimapMarker(DXML, element)
  if not element then
    return
  end

  DXML:iterateChildren(element, function(child)
    if
      not DXML:isElement(child)
      or DXML:getElementName(child) == "texture"
      or DXML:getElementName(child):match("^texture_")
    then
      return
    end

    -- only shift minimap markers (no resize)
    DART.editAttributes(DXML, child, function(attrs)
      local x = attrs.x / DART.getAspectRatioVs16x9()

      -- Extra fudge factor for blinky things
      if DXML:getElementName(child) == "static_border" then
        x = x  + 1
      end

      return {x = x}
    end)
  end)
end


-- Pre-index markers for performance
function buildMarkerIndex(DXML)
  DXML:iterateChildren(DXML:getRoot(), function(element)
    if not isResizable(DXML, element) then
      return
    end

    local name = DXML:getElementName(element)

    -- Delete duplicate markers from XML
    if MARKER_INDEX[name] then
      log("Removing duplicate marker " .. name)
      DXML:removeElement(MARKER_INDEX[name])
    end

    MARKER_INDEX[name] = element
  end)
end


function adjustPDAMarkers(DXML)
  DART.ipairscb({"level_map", "complex_spot"}, function(query)
    local definitions = DXML:query(query)

    if not definitions then
      return
    end

    DART.ipairscb(definitions, function(definition)
      local miniDefinition = DXML:query("mini_map", definition.parent)[1]

      DART.ipairscb({"spot", "pointer"}, function(attribute)
        local name, miniName = DXML:getElementAttr(definition)[attribute]

        if not name or not MARKER_INDEX[name] then
         return
        end

        if miniDefinition then
          miniName = DXML:getElementAttr(miniDefinition)[attribute]
        end

        if miniName == name then
          miniName = miniName .. "_mini"

          if not MARKER_INDEX[miniName] then
            MARKER_INDEX[miniName] = DXML:insertElement({
              name = miniName,
              attr = DXML:getElementAttr(MARKER_INDEX[name]),
              kids = MARKER_INDEX[name].kids
            })
          end

          DXML:setElementAttr(miniDefinition, {[attribute] = miniName})
        end

        if
          not TOUCHED[MARKER_INDEX[name]]
          and isResizable(DXML, MARKER_INDEX[name])
        then
          resizePDAMarker(DXML, MARKER_INDEX[name])

          DXML:iterateChildren(MARKER_INDEX[name], function(child)
            if isResizable(DXML, child) then
              resizePDAMarker(DXML, child)
            end
          end)

          TOUCHED[MARKER_INDEX[name]] = true
        end
      end)
    end)
  end)
end


function adjustMinimapMarkers(DXML)
  local definitions = DXML:query("mini_map")

  if not definitions then
    return
  end

  DART.ipairscb(definitions, function(definition)
    DART.ipairscb({"spot", "pointer"}, function(attribute)
      local name = DXML:getElementAttr(definition)[attribute]

      if
        not name
        or not MARKER_INDEX[name]
        or TOUCHED[MARKER_INDEX[name]]
      then
        return
      end

      adjustMinimapMarker(DXML, MARKER_INDEX[name])
      TOUCHED[MARKER_INDEX[name]] = true
    end)
  end)
end


function onReadMapSpotsXML(filename, DXML)
  if
    not filename:match([[^ui\map_spots]])
    or DART.getAspectRatioVs16x9() <= 1
    or not DART.isUsing3DPDA()
  then
    return
  end

  if applyCache(filename, DXML) then
    return
  end

  log("Parsing " .. filename)

  buildMarkerIndex(DXML)
  adjustPDAMarkers(DXML)
  adjustMinimapMarkers(DXML)

  setCache(filename, DXML)
  MARKER_INDEX, TOUCHED = {}, {}
end


function on_xml_read()
  RegisterScriptCallback("on_xml_read", onReadMapSpotsXML)
end
